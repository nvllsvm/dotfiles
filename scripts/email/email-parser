#!/usr/bin/env python3
import argparse
import collections
import email
import email.message
import json
import pathlib
import sys


def _argparse_path_not_exists(path):
    path = pathlib.Path(path)
    if path.is_file():
        raise argparse.ArgumentTypeError("path must not be a file")
    return path


def parse_headers(message: email.message.Message) -> dict:
    headers = {}
    for key, _ in message.items():
        value = message.get_all(key)
        if len(value) == 1:
            value = value[0]
        headers[key] = value
    return headers


def main():
    parser = argparse.ArgumentParser(
        "email-parser", description="Parse a raw email into separate, decoded files"
    )
    parser.add_argument("-c", "--content-type")
    parser.add_argument("email", type=argparse.FileType("r"), help="raw email content")
    parser.add_argument(
        "output",
        type=_argparse_path_not_exists,
        nargs="?",
        help="directory to output to. created if it does not exist.",
    )
    args = parser.parse_args()

    message = email.message_from_file(args.email)
    if args.output:
        output_dir = args.output

        output_dir.mkdir(parents=True, exist_ok=True)

        target = output_dir.joinpath("headers.json")
        print(f"Headers --> {target.name}")
        target.write_text(
            json.dumps(
                parse_headers(message), sort_keys=True, indent=2, ensure_ascii=False
            )
        )

        ct_counts = collections.defaultdict(int)
        for part in message.walk():
            ct = part.get_content_type()
            ct_sanitized = ct.replace("/", "_")
            target = output_dir.joinpath(f"{ct_sanitized}_{ct_counts[ct]}")
            print(f"Part {ct} --> {target.name}")
            ct_counts[ct] += 1
            if not part.is_multipart():
                target.write_bytes(part.get_payload(decode=True))
    else:
        if args.content_type:
            found = None
            for part in message.walk():
                ct = part.get_content_type()
                if ct == args.content_type:
                    if found is not None:
                        print(
                            "error: multiple parts with content type", file=sys.stderr
                        )
                        sys.exit(1)
                    found = part.get_payload(decode=True)
            if found is None:
                print("error: content-type not found in message", file=sys.stderr)
                sys.exit(1)
            sys.stdout.buffer.write(found)
        else:
            print(
                json.dumps(
                    parse_headers(message), sort_keys=True, indent=2, ensure_ascii=False
                )
            )


if __name__ == "__main__":
    main()
