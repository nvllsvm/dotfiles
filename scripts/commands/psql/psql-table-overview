#!/usr/bin/env python3
import argparse
import json
import subprocess


SQL = """
SELECT table_schema,
       table_name,
       ordinal_position,
       column_name
  FROM information_schema.columns
  ORDER BY 1, 2, 3
"""


def flatten_dict(root, separator="/"):
    stack = [([], root)]
    flat = {}
    while stack:
        prefixes, data = stack.pop()
        for key, value in data.items():
            prefix = prefixes.copy()
            prefix.append(key)

            if isinstance(value, dict):
                stack.append((prefix, value))
            else:
                if any(separator in part for part in prefix):
                    raise ValueError("separator found in prefix")
                flat_key = separator.join(prefix)
                if flat_key in flat:
                    raise KeyError(f'duplicate key "{flat_key}"')
                flat[flat_key] = value
    return flat


def pretty_json(data):
    return json.dumps(data, indent=2, sort_keys=True)


def get_tree(url):
    schemas = {}
    proc = subprocess.run(
        ["psql", url, "--no-psqlrc", "--tuples-only", "--csv", "--command", SQL],
        stdout=subprocess.PIPE,
        check=True,
    )
    for line in proc.stdout.decode().splitlines():
        schema, table, _, column_name = line.split(",")
        schemas.setdefault(schema, {})
        schemas[schema].setdefault(table, [])
        schemas[schema][table].append(column_name)
    return schemas


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--flat", action="store_true")
    parser.add_argument("--schema", action="append")
    parser.add_argument("url")
    args = parser.parse_args()

    tree = get_tree(args.url)
    if args.schema:
        tree = {key: value for key, value in tree.items() if key in args.schema}

    if args.flat:
        for key, values in flatten_dict(tree, ".").items():
            for value in values:
                print(".".join([key, value]))
    else:
        print(pretty_json(tree))


if __name__ == "__main__":
    main()
